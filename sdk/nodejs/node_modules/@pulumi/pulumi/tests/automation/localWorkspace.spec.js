"use strict";
// Copyright 2016-2020, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const upath = require("upath");
const index_1 = require("../../index");
const automation_1 = require("../../x/automation");
const util_1 = require("../util");
describe("LocalWorkspace", () => {
    it(`projectSettings from yaml/yml/json`, util_1.asyncTest(() => __awaiter(void 0, void 0, void 0, function* () {
        for (const ext of ["yaml", "yml", "json"]) {
            const ws = yield automation_1.LocalWorkspace.create({ workDir: upath.joinSafe(__dirname, "data", ext) });
            const settings = yield ws.projectSettings();
            assert(settings.name, "testproj");
            assert(settings.runtime, "go");
            assert(settings.description, "A minimal Go Pulumi program");
        }
    })));
    it(`stackSettings from yaml/yml/json`, util_1.asyncTest(() => __awaiter(void 0, void 0, void 0, function* () {
        for (const ext of ["yaml", "yml", "json"]) {
            const ws = yield automation_1.LocalWorkspace.create({ workDir: upath.joinSafe(__dirname, "data", ext) });
            const settings = yield ws.stackSettings("dev");
            assert.strictEqual(settings.secretsProvider, "abc");
            assert.strictEqual(settings.config["plain"], "plain");
            assert.strictEqual(settings.config["secure"].secure, "secret");
        }
    })));
    it(`adds/removes/lists plugins successfully`, util_1.asyncTest(() => __awaiter(void 0, void 0, void 0, function* () {
        const ws = yield automation_1.LocalWorkspace.create({});
        yield ws.installPlugin("aws", "v3.0.0");
        yield ws.removePlugin("aws", "3.0.0");
        yield ws.listPlugins();
    })));
    it(`create/select/remove LocalWorkspace stack`, util_1.asyncTest(() => __awaiter(void 0, void 0, void 0, function* () {
        const projectSettings = {
            name: "node_test",
            runtime: "nodejs",
        };
        const ws = yield automation_1.LocalWorkspace.create({ projectSettings });
        const stackName = `int_test${getTestSuffix()}`;
        yield ws.createStack(stackName);
        yield ws.selectStack(stackName);
        yield ws.removeStack(stackName);
    })));
    it(`create/select/createOrSelect Stack`, util_1.asyncTest(() => __awaiter(void 0, void 0, void 0, function* () {
        const projectSettings = {
            name: "node_test",
            runtime: "nodejs",
        };
        const ws = yield automation_1.LocalWorkspace.create({ projectSettings });
        const stackName = `int_test${getTestSuffix()}`;
        yield automation_1.Stack.create(stackName, ws);
        yield automation_1.Stack.select(stackName, ws);
        yield automation_1.Stack.createOrSelect(stackName, ws);
        yield ws.removeStack(stackName);
    })));
    it(`Config`, util_1.asyncTest(() => __awaiter(void 0, void 0, void 0, function* () {
        const projectName = "node_test";
        const projectSettings = {
            name: projectName,
            runtime: "nodejs",
        };
        const ws = yield automation_1.LocalWorkspace.create({ projectSettings });
        const stackName = `int_test${getTestSuffix()}`;
        const stack = yield automation_1.Stack.create(stackName, ws);
        const config = {
            plain: { value: "abc" },
            secret: { value: "def", secret: true },
        };
        let caught = 0;
        const plainKey = normalizeConfigKey("plain", projectName);
        const secretKey = normalizeConfigKey("secret", projectName);
        try {
            yield stack.getConfig(plainKey);
        }
        catch (error) {
            caught++;
        }
        assert.strictEqual(caught, 1, "expected config get on empty value to throw");
        let values = yield stack.getAllConfig();
        assert.strictEqual(Object.keys(values).length, 0, "expected stack config to be empty");
        yield stack.setAllConfig(config);
        values = yield stack.getAllConfig();
        assert.strictEqual(values[plainKey].value, "abc");
        assert.strictEqual(values[plainKey].secret, false);
        assert.strictEqual(values[secretKey].value, "def");
        assert.strictEqual(values[secretKey].secret, true);
        yield stack.removeConfig("plain");
        values = yield stack.getAllConfig();
        assert.strictEqual(Object.keys(values).length, 1, "expected stack config to have 1 value");
        yield stack.setConfig("foo", { value: "bar" });
        values = yield stack.getAllConfig();
        assert.strictEqual(Object.keys(values).length, 2, "expected stack config to have 2 values");
        yield ws.removeStack(stackName);
    })));
    it(`can list stacks and currently selected stack`, util_1.asyncTest(() => __awaiter(void 0, void 0, void 0, function* () {
        var _a;
        const projectSettings = {
            name: `node_list_test${getTestSuffix()}`,
            runtime: "nodejs",
        };
        const ws = yield automation_1.LocalWorkspace.create({ projectSettings });
        const stackNamer = () => `int_test${getTestSuffix()}`;
        const stackNames = [];
        for (let i = 0; i < 2; i++) {
            const stackName = stackNamer();
            stackNames[i] = stackName;
            yield automation_1.Stack.create(stackName, ws);
            const stackSummary = yield ws.stack();
            assert.strictEqual((_a = stackSummary) === null || _a === void 0 ? void 0 : _a.current, true);
            const stacks = yield ws.listStacks();
            assert.strictEqual(stacks.length, i + 1);
        }
        for (const name of stackNames) {
            yield ws.removeStack(name);
        }
    })));
    it(`stack status methods`, util_1.asyncTest(() => __awaiter(void 0, void 0, void 0, function* () {
        const projectSettings = {
            name: "node_test",
            runtime: "nodejs",
        };
        const ws = yield automation_1.LocalWorkspace.create({ projectSettings });
        const stackName = `int_test${getTestSuffix()}`;
        const stack = yield automation_1.Stack.create(stackName, ws);
        const history = yield stack.history();
        assert.strictEqual(history.length, 0);
        const info = yield stack.info();
        assert.strictEqual(typeof (info), "undefined");
        yield ws.removeStack(stackName);
    })));
    it(`runs through the stack lifecycle with a local program`, util_1.asyncTest(() => __awaiter(void 0, void 0, void 0, function* () {
        const stackName = `int_test${getTestSuffix()}`;
        const workDir = upath.joinSafe(__dirname, "data", "testproj");
        const stack = yield automation_1.LocalWorkspace.createStack({ stackName, workDir });
        const config = {
            "bar": { value: "abc" },
            "buzz": { value: "secret", secret: true },
        };
        yield stack.setAllConfig(config);
        // pulumi up
        const upRes = yield stack.up();
        assert.strictEqual(Object.keys(upRes.outputs).length, 3);
        assert.strictEqual(upRes.outputs["exp_static"].value, "foo");
        assert.strictEqual(upRes.outputs["exp_static"].secret, false);
        assert.strictEqual(upRes.outputs["exp_cfg"].value, "abc");
        assert.strictEqual(upRes.outputs["exp_cfg"].secret, false);
        assert.strictEqual(upRes.outputs["exp_secret"].value, "secret");
        assert.strictEqual(upRes.outputs["exp_secret"].secret, true);
        assert.strictEqual(upRes.summary.kind, "update");
        assert.strictEqual(upRes.summary.result, "succeeded");
        // pulumi preview
        yield stack.preview();
        // TODO: update assertions when we have structured output
        // pulumi refresh
        const refRes = yield stack.refresh();
        assert.strictEqual(refRes.summary.kind, "refresh");
        assert.strictEqual(refRes.summary.result, "succeeded");
        // pulumi destroy
        const destroyRes = yield stack.destroy();
        assert.strictEqual(destroyRes.summary.kind, "destroy");
        assert.strictEqual(destroyRes.summary.result, "succeeded");
        yield stack.workspace.removeStack(stackName);
    })));
    it(`runs through the stack lifecycle with an inline program`, util_1.asyncTest(() => __awaiter(void 0, void 0, void 0, function* () {
        const program = () => __awaiter(void 0, void 0, void 0, function* () {
            const config = new index_1.Config();
            return {
                exp_static: "foo",
                exp_cfg: config.get("bar"),
                exp_secret: config.getSecret("buzz"),
            };
        });
        const stackName = `int_test${getTestSuffix()}`;
        const projectName = "inline_node";
        const stack = yield automation_1.LocalWorkspace.createStack({ stackName, projectName, program });
        const stackConfig = {
            "bar": { value: "abc" },
            "buzz": { value: "secret", secret: true },
        };
        yield stack.setAllConfig(stackConfig);
        // pulumi up
        const upRes = yield stack.up();
        assert.strictEqual(Object.keys(upRes.outputs).length, 3);
        assert.strictEqual(upRes.outputs["exp_static"].value, "foo");
        assert.strictEqual(upRes.outputs["exp_static"].secret, false);
        assert.strictEqual(upRes.outputs["exp_cfg"].value, "abc");
        assert.strictEqual(upRes.outputs["exp_cfg"].secret, false);
        assert.strictEqual(upRes.outputs["exp_secret"].value, "secret");
        assert.strictEqual(upRes.outputs["exp_secret"].secret, true);
        assert.strictEqual(upRes.summary.kind, "update");
        assert.strictEqual(upRes.summary.result, "succeeded");
        // pulumi preview
        yield stack.preview();
        // TODO: update assertions when we have structured output
        // pulumi refresh
        const refRes = yield stack.refresh();
        assert.strictEqual(refRes.summary.kind, "refresh");
        assert.strictEqual(refRes.summary.result, "succeeded");
        // pulumi destroy
        const destroyRes = yield stack.destroy();
        assert.strictEqual(destroyRes.summary.kind, "destroy");
        assert.strictEqual(destroyRes.summary.result, "succeeded");
        yield stack.workspace.removeStack(stackName);
    })));
    it(`imports and exports stacks`, util_1.asyncTest(() => __awaiter(void 0, void 0, void 0, function* () {
        const program = () => __awaiter(void 0, void 0, void 0, function* () {
            const config = new index_1.Config();
            return {
                exp_static: "foo",
                exp_cfg: config.get("bar"),
                exp_secret: config.getSecret("buzz"),
            };
        });
        const stackName = `int_test${getTestSuffix()}`;
        const projectName = "import_export_node";
        const stack = yield automation_1.LocalWorkspace.createStack({ stackName, projectName, program });
        try {
            yield stack.setAllConfig({
                "bar": { value: "abc" },
                "buzz": { value: "secret", secret: true },
            });
            yield stack.up();
            // export stack
            const state = yield stack.exportStack();
            // import stack
            yield stack.importStack(state);
            const configVal = yield stack.getConfig("bar");
            assert.strictEqual(configVal.value, "abc");
        }
        finally {
            const destroyRes = yield stack.destroy();
            assert.strictEqual(destroyRes.summary.kind, "destroy");
            assert.strictEqual(destroyRes.summary.result, "succeeded");
            yield stack.workspace.removeStack(stackName);
        }
    })));
    it(`runs an inline program that rejects a promise and exits gracefully`, util_1.asyncTest(() => __awaiter(void 0, void 0, void 0, function* () {
        const program = () => __awaiter(void 0, void 0, void 0, function* () {
            Promise.reject(new Error());
            return {};
        });
        const stackName = `int_test${getTestSuffix()}`;
        const projectName = "inline_node";
        const stack = yield automation_1.LocalWorkspace.createStack({ stackName, projectName, program });
        // pulumi up        
        yield assert.rejects(stack.up());
        // pulumi destroy
        const destroyRes = yield stack.destroy();
        assert.strictEqual(destroyRes.summary.kind, "destroy");
        assert.strictEqual(destroyRes.summary.result, "succeeded");
        yield stack.workspace.removeStack(stackName);
    })));
});
const getTestSuffix = () => {
    return Math.floor(100000 + Math.random() * 900000);
};
const normalizeConfigKey = (key, projectName) => {
    const parts = key.split(":");
    if (parts.length < 2) {
        return `${projectName}:${key}`;
    }
    return "";
};
