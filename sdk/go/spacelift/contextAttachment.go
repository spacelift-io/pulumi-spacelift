// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package spacelift

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/spacelift-io/pulumi-spacelift/sdk/v2/go/spacelift/internal"
)

// `ContextAttachment` represents a Spacelift attachment of a single context to a single stack or module, with a predefined priority.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/spacelift-io/pulumi-spacelift/sdk/v2/go/spacelift"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			// For a module
//			_, err := spacelift.NewContextAttachment(ctx, "attachment", &spacelift.ContextAttachmentArgs{
//				ContextId: pulumi.String("prod-k8s-ie"),
//				ModuleId:  pulumi.String("k8s-module"),
//				Priority:  pulumi.Int(0),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// ```sh
//
//	$ pulumi import spacelift:index/contextAttachment:ContextAttachment test_stack $CONTEXT_ID/$STACK_ID
//
// ```
type ContextAttachment struct {
	pulumi.CustomResourceState

	// ID of the context to attach
	ContextId pulumi.StringOutput `pulumi:"contextId"`
	// ID of the module to attach the context to
	ModuleId pulumi.StringPtrOutput `pulumi:"moduleId"`
	// Priority of the context attachment. All the contexts attached to a stack are sorted by priority (lowest first), though values don't need to be unique. This ordering establishes precedence rules between contexts should there be a conflict and multiple contexts define the same value. Defaults to `0`.
	Priority pulumi.IntPtrOutput `pulumi:"priority"`
	// ID of the stack to attach the context to
	StackId pulumi.StringPtrOutput `pulumi:"stackId"`
}

// NewContextAttachment registers a new resource with the given unique name, arguments, and options.
func NewContextAttachment(ctx *pulumi.Context,
	name string, args *ContextAttachmentArgs, opts ...pulumi.ResourceOption) (*ContextAttachment, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ContextId == nil {
		return nil, errors.New("invalid value for required argument 'ContextId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ContextAttachment
	err := ctx.RegisterResource("spacelift:index/contextAttachment:ContextAttachment", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetContextAttachment gets an existing ContextAttachment resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetContextAttachment(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ContextAttachmentState, opts ...pulumi.ResourceOption) (*ContextAttachment, error) {
	var resource ContextAttachment
	err := ctx.ReadResource("spacelift:index/contextAttachment:ContextAttachment", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ContextAttachment resources.
type contextAttachmentState struct {
	// ID of the context to attach
	ContextId *string `pulumi:"contextId"`
	// ID of the module to attach the context to
	ModuleId *string `pulumi:"moduleId"`
	// Priority of the context attachment. All the contexts attached to a stack are sorted by priority (lowest first), though values don't need to be unique. This ordering establishes precedence rules between contexts should there be a conflict and multiple contexts define the same value. Defaults to `0`.
	Priority *int `pulumi:"priority"`
	// ID of the stack to attach the context to
	StackId *string `pulumi:"stackId"`
}

type ContextAttachmentState struct {
	// ID of the context to attach
	ContextId pulumi.StringPtrInput
	// ID of the module to attach the context to
	ModuleId pulumi.StringPtrInput
	// Priority of the context attachment. All the contexts attached to a stack are sorted by priority (lowest first), though values don't need to be unique. This ordering establishes precedence rules between contexts should there be a conflict and multiple contexts define the same value. Defaults to `0`.
	Priority pulumi.IntPtrInput
	// ID of the stack to attach the context to
	StackId pulumi.StringPtrInput
}

func (ContextAttachmentState) ElementType() reflect.Type {
	return reflect.TypeOf((*contextAttachmentState)(nil)).Elem()
}

type contextAttachmentArgs struct {
	// ID of the context to attach
	ContextId string `pulumi:"contextId"`
	// ID of the module to attach the context to
	ModuleId *string `pulumi:"moduleId"`
	// Priority of the context attachment. All the contexts attached to a stack are sorted by priority (lowest first), though values don't need to be unique. This ordering establishes precedence rules between contexts should there be a conflict and multiple contexts define the same value. Defaults to `0`.
	Priority *int `pulumi:"priority"`
	// ID of the stack to attach the context to
	StackId *string `pulumi:"stackId"`
}

// The set of arguments for constructing a ContextAttachment resource.
type ContextAttachmentArgs struct {
	// ID of the context to attach
	ContextId pulumi.StringInput
	// ID of the module to attach the context to
	ModuleId pulumi.StringPtrInput
	// Priority of the context attachment. All the contexts attached to a stack are sorted by priority (lowest first), though values don't need to be unique. This ordering establishes precedence rules between contexts should there be a conflict and multiple contexts define the same value. Defaults to `0`.
	Priority pulumi.IntPtrInput
	// ID of the stack to attach the context to
	StackId pulumi.StringPtrInput
}

func (ContextAttachmentArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*contextAttachmentArgs)(nil)).Elem()
}

type ContextAttachmentInput interface {
	pulumi.Input

	ToContextAttachmentOutput() ContextAttachmentOutput
	ToContextAttachmentOutputWithContext(ctx context.Context) ContextAttachmentOutput
}

func (*ContextAttachment) ElementType() reflect.Type {
	return reflect.TypeOf((**ContextAttachment)(nil)).Elem()
}

func (i *ContextAttachment) ToContextAttachmentOutput() ContextAttachmentOutput {
	return i.ToContextAttachmentOutputWithContext(context.Background())
}

func (i *ContextAttachment) ToContextAttachmentOutputWithContext(ctx context.Context) ContextAttachmentOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContextAttachmentOutput)
}

// ContextAttachmentArrayInput is an input type that accepts ContextAttachmentArray and ContextAttachmentArrayOutput values.
// You can construct a concrete instance of `ContextAttachmentArrayInput` via:
//
//	ContextAttachmentArray{ ContextAttachmentArgs{...} }
type ContextAttachmentArrayInput interface {
	pulumi.Input

	ToContextAttachmentArrayOutput() ContextAttachmentArrayOutput
	ToContextAttachmentArrayOutputWithContext(context.Context) ContextAttachmentArrayOutput
}

type ContextAttachmentArray []ContextAttachmentInput

func (ContextAttachmentArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ContextAttachment)(nil)).Elem()
}

func (i ContextAttachmentArray) ToContextAttachmentArrayOutput() ContextAttachmentArrayOutput {
	return i.ToContextAttachmentArrayOutputWithContext(context.Background())
}

func (i ContextAttachmentArray) ToContextAttachmentArrayOutputWithContext(ctx context.Context) ContextAttachmentArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContextAttachmentArrayOutput)
}

// ContextAttachmentMapInput is an input type that accepts ContextAttachmentMap and ContextAttachmentMapOutput values.
// You can construct a concrete instance of `ContextAttachmentMapInput` via:
//
//	ContextAttachmentMap{ "key": ContextAttachmentArgs{...} }
type ContextAttachmentMapInput interface {
	pulumi.Input

	ToContextAttachmentMapOutput() ContextAttachmentMapOutput
	ToContextAttachmentMapOutputWithContext(context.Context) ContextAttachmentMapOutput
}

type ContextAttachmentMap map[string]ContextAttachmentInput

func (ContextAttachmentMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ContextAttachment)(nil)).Elem()
}

func (i ContextAttachmentMap) ToContextAttachmentMapOutput() ContextAttachmentMapOutput {
	return i.ToContextAttachmentMapOutputWithContext(context.Background())
}

func (i ContextAttachmentMap) ToContextAttachmentMapOutputWithContext(ctx context.Context) ContextAttachmentMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContextAttachmentMapOutput)
}

type ContextAttachmentOutput struct{ *pulumi.OutputState }

func (ContextAttachmentOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ContextAttachment)(nil)).Elem()
}

func (o ContextAttachmentOutput) ToContextAttachmentOutput() ContextAttachmentOutput {
	return o
}

func (o ContextAttachmentOutput) ToContextAttachmentOutputWithContext(ctx context.Context) ContextAttachmentOutput {
	return o
}

// ID of the context to attach
func (o ContextAttachmentOutput) ContextId() pulumi.StringOutput {
	return o.ApplyT(func(v *ContextAttachment) pulumi.StringOutput { return v.ContextId }).(pulumi.StringOutput)
}

// ID of the module to attach the context to
func (o ContextAttachmentOutput) ModuleId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ContextAttachment) pulumi.StringPtrOutput { return v.ModuleId }).(pulumi.StringPtrOutput)
}

// Priority of the context attachment. All the contexts attached to a stack are sorted by priority (lowest first), though values don't need to be unique. This ordering establishes precedence rules between contexts should there be a conflict and multiple contexts define the same value. Defaults to `0`.
func (o ContextAttachmentOutput) Priority() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ContextAttachment) pulumi.IntPtrOutput { return v.Priority }).(pulumi.IntPtrOutput)
}

// ID of the stack to attach the context to
func (o ContextAttachmentOutput) StackId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ContextAttachment) pulumi.StringPtrOutput { return v.StackId }).(pulumi.StringPtrOutput)
}

type ContextAttachmentArrayOutput struct{ *pulumi.OutputState }

func (ContextAttachmentArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ContextAttachment)(nil)).Elem()
}

func (o ContextAttachmentArrayOutput) ToContextAttachmentArrayOutput() ContextAttachmentArrayOutput {
	return o
}

func (o ContextAttachmentArrayOutput) ToContextAttachmentArrayOutputWithContext(ctx context.Context) ContextAttachmentArrayOutput {
	return o
}

func (o ContextAttachmentArrayOutput) Index(i pulumi.IntInput) ContextAttachmentOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ContextAttachment {
		return vs[0].([]*ContextAttachment)[vs[1].(int)]
	}).(ContextAttachmentOutput)
}

type ContextAttachmentMapOutput struct{ *pulumi.OutputState }

func (ContextAttachmentMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ContextAttachment)(nil)).Elem()
}

func (o ContextAttachmentMapOutput) ToContextAttachmentMapOutput() ContextAttachmentMapOutput {
	return o
}

func (o ContextAttachmentMapOutput) ToContextAttachmentMapOutputWithContext(ctx context.Context) ContextAttachmentMapOutput {
	return o
}

func (o ContextAttachmentMapOutput) MapIndex(k pulumi.StringInput) ContextAttachmentOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ContextAttachment {
		return vs[0].(map[string]*ContextAttachment)[vs[1].(string)]
	}).(ContextAttachmentOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ContextAttachmentInput)(nil)).Elem(), &ContextAttachment{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContextAttachmentArrayInput)(nil)).Elem(), ContextAttachmentArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContextAttachmentMapInput)(nil)).Elem(), ContextAttachmentMap{})
	pulumi.RegisterOutputType(ContextAttachmentOutput{})
	pulumi.RegisterOutputType(ContextAttachmentArrayOutput{})
	pulumi.RegisterOutputType(ContextAttachmentMapOutput{})
}
