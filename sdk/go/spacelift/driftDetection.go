// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package spacelift

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// `DriftDetection` represents a Drift Detection configuration for a Stack. It will trigger a proposed run on the given schedule, which you can listen for using run state webhooks. If reconcile is true, then a tracked run will be triggered when drift is detected.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/spacelift-io/pulumi-spacelift/sdk/go/spacelift"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := spacelift.NewStack(ctx, "core-infra-production", &spacelift.StackArgs{
//				Branch:     pulumi.String("master"),
//				Repository: pulumi.String("core-infra"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = spacelift.NewDriftDetection(ctx, "core-infra-production-drift-detection", &spacelift.DriftDetectionArgs{
//				Reconcile: pulumi.Bool(true),
//				StackId:   core_infra_production.ID(),
//				Schedules: pulumi.StringArray{
//					pulumi.String("*/15 * * * *"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// ```sh
//
//	$ pulumi import spacelift:index/driftDetection:DriftDetection core-infra-production-drift-detection stack/$STACK_ID
//
// ```
//
// ```sh
//
//	$ pulumi import spacelift:index/driftDetection:DriftDetection core-infra-production-drift-detection module/$MODULE_ID
//
// ```
type DriftDetection struct {
	pulumi.CustomResourceState

	// Whether a tracked run should be triggered when drift is detected.
	Reconcile pulumi.BoolPtrOutput `pulumi:"reconcile"`
	// List of cron schedule expressions based on which drift detection should be triggered.
	Schedules pulumi.StringArrayOutput `pulumi:"schedules"`
	// ID of the stack for which to set up drift detection
	StackId pulumi.StringOutput `pulumi:"stackId"`
	// Timezone in which the schedule is expressed. Defaults to `UTC`.
	Timezone pulumi.StringPtrOutput `pulumi:"timezone"`
}

// NewDriftDetection registers a new resource with the given unique name, arguments, and options.
func NewDriftDetection(ctx *pulumi.Context,
	name string, args *DriftDetectionArgs, opts ...pulumi.ResourceOption) (*DriftDetection, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Schedules == nil {
		return nil, errors.New("invalid value for required argument 'Schedules'")
	}
	if args.StackId == nil {
		return nil, errors.New("invalid value for required argument 'StackId'")
	}
	opts = pkgResourceDefaultOpts(opts)
	var resource DriftDetection
	err := ctx.RegisterResource("spacelift:index/driftDetection:DriftDetection", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetDriftDetection gets an existing DriftDetection resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetDriftDetection(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *DriftDetectionState, opts ...pulumi.ResourceOption) (*DriftDetection, error) {
	var resource DriftDetection
	err := ctx.ReadResource("spacelift:index/driftDetection:DriftDetection", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering DriftDetection resources.
type driftDetectionState struct {
	// Whether a tracked run should be triggered when drift is detected.
	Reconcile *bool `pulumi:"reconcile"`
	// List of cron schedule expressions based on which drift detection should be triggered.
	Schedules []string `pulumi:"schedules"`
	// ID of the stack for which to set up drift detection
	StackId *string `pulumi:"stackId"`
	// Timezone in which the schedule is expressed. Defaults to `UTC`.
	Timezone *string `pulumi:"timezone"`
}

type DriftDetectionState struct {
	// Whether a tracked run should be triggered when drift is detected.
	Reconcile pulumi.BoolPtrInput
	// List of cron schedule expressions based on which drift detection should be triggered.
	Schedules pulumi.StringArrayInput
	// ID of the stack for which to set up drift detection
	StackId pulumi.StringPtrInput
	// Timezone in which the schedule is expressed. Defaults to `UTC`.
	Timezone pulumi.StringPtrInput
}

func (DriftDetectionState) ElementType() reflect.Type {
	return reflect.TypeOf((*driftDetectionState)(nil)).Elem()
}

type driftDetectionArgs struct {
	// Whether a tracked run should be triggered when drift is detected.
	Reconcile *bool `pulumi:"reconcile"`
	// List of cron schedule expressions based on which drift detection should be triggered.
	Schedules []string `pulumi:"schedules"`
	// ID of the stack for which to set up drift detection
	StackId string `pulumi:"stackId"`
	// Timezone in which the schedule is expressed. Defaults to `UTC`.
	Timezone *string `pulumi:"timezone"`
}

// The set of arguments for constructing a DriftDetection resource.
type DriftDetectionArgs struct {
	// Whether a tracked run should be triggered when drift is detected.
	Reconcile pulumi.BoolPtrInput
	// List of cron schedule expressions based on which drift detection should be triggered.
	Schedules pulumi.StringArrayInput
	// ID of the stack for which to set up drift detection
	StackId pulumi.StringInput
	// Timezone in which the schedule is expressed. Defaults to `UTC`.
	Timezone pulumi.StringPtrInput
}

func (DriftDetectionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*driftDetectionArgs)(nil)).Elem()
}

type DriftDetectionInput interface {
	pulumi.Input

	ToDriftDetectionOutput() DriftDetectionOutput
	ToDriftDetectionOutputWithContext(ctx context.Context) DriftDetectionOutput
}

func (*DriftDetection) ElementType() reflect.Type {
	return reflect.TypeOf((**DriftDetection)(nil)).Elem()
}

func (i *DriftDetection) ToDriftDetectionOutput() DriftDetectionOutput {
	return i.ToDriftDetectionOutputWithContext(context.Background())
}

func (i *DriftDetection) ToDriftDetectionOutputWithContext(ctx context.Context) DriftDetectionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DriftDetectionOutput)
}

// DriftDetectionArrayInput is an input type that accepts DriftDetectionArray and DriftDetectionArrayOutput values.
// You can construct a concrete instance of `DriftDetectionArrayInput` via:
//
//	DriftDetectionArray{ DriftDetectionArgs{...} }
type DriftDetectionArrayInput interface {
	pulumi.Input

	ToDriftDetectionArrayOutput() DriftDetectionArrayOutput
	ToDriftDetectionArrayOutputWithContext(context.Context) DriftDetectionArrayOutput
}

type DriftDetectionArray []DriftDetectionInput

func (DriftDetectionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*DriftDetection)(nil)).Elem()
}

func (i DriftDetectionArray) ToDriftDetectionArrayOutput() DriftDetectionArrayOutput {
	return i.ToDriftDetectionArrayOutputWithContext(context.Background())
}

func (i DriftDetectionArray) ToDriftDetectionArrayOutputWithContext(ctx context.Context) DriftDetectionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DriftDetectionArrayOutput)
}

// DriftDetectionMapInput is an input type that accepts DriftDetectionMap and DriftDetectionMapOutput values.
// You can construct a concrete instance of `DriftDetectionMapInput` via:
//
//	DriftDetectionMap{ "key": DriftDetectionArgs{...} }
type DriftDetectionMapInput interface {
	pulumi.Input

	ToDriftDetectionMapOutput() DriftDetectionMapOutput
	ToDriftDetectionMapOutputWithContext(context.Context) DriftDetectionMapOutput
}

type DriftDetectionMap map[string]DriftDetectionInput

func (DriftDetectionMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*DriftDetection)(nil)).Elem()
}

func (i DriftDetectionMap) ToDriftDetectionMapOutput() DriftDetectionMapOutput {
	return i.ToDriftDetectionMapOutputWithContext(context.Background())
}

func (i DriftDetectionMap) ToDriftDetectionMapOutputWithContext(ctx context.Context) DriftDetectionMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DriftDetectionMapOutput)
}

type DriftDetectionOutput struct{ *pulumi.OutputState }

func (DriftDetectionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DriftDetection)(nil)).Elem()
}

func (o DriftDetectionOutput) ToDriftDetectionOutput() DriftDetectionOutput {
	return o
}

func (o DriftDetectionOutput) ToDriftDetectionOutputWithContext(ctx context.Context) DriftDetectionOutput {
	return o
}

// Whether a tracked run should be triggered when drift is detected.
func (o DriftDetectionOutput) Reconcile() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *DriftDetection) pulumi.BoolPtrOutput { return v.Reconcile }).(pulumi.BoolPtrOutput)
}

// List of cron schedule expressions based on which drift detection should be triggered.
func (o DriftDetectionOutput) Schedules() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *DriftDetection) pulumi.StringArrayOutput { return v.Schedules }).(pulumi.StringArrayOutput)
}

// ID of the stack for which to set up drift detection
func (o DriftDetectionOutput) StackId() pulumi.StringOutput {
	return o.ApplyT(func(v *DriftDetection) pulumi.StringOutput { return v.StackId }).(pulumi.StringOutput)
}

// Timezone in which the schedule is expressed. Defaults to `UTC`.
func (o DriftDetectionOutput) Timezone() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DriftDetection) pulumi.StringPtrOutput { return v.Timezone }).(pulumi.StringPtrOutput)
}

type DriftDetectionArrayOutput struct{ *pulumi.OutputState }

func (DriftDetectionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*DriftDetection)(nil)).Elem()
}

func (o DriftDetectionArrayOutput) ToDriftDetectionArrayOutput() DriftDetectionArrayOutput {
	return o
}

func (o DriftDetectionArrayOutput) ToDriftDetectionArrayOutputWithContext(ctx context.Context) DriftDetectionArrayOutput {
	return o
}

func (o DriftDetectionArrayOutput) Index(i pulumi.IntInput) DriftDetectionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *DriftDetection {
		return vs[0].([]*DriftDetection)[vs[1].(int)]
	}).(DriftDetectionOutput)
}

type DriftDetectionMapOutput struct{ *pulumi.OutputState }

func (DriftDetectionMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*DriftDetection)(nil)).Elem()
}

func (o DriftDetectionMapOutput) ToDriftDetectionMapOutput() DriftDetectionMapOutput {
	return o
}

func (o DriftDetectionMapOutput) ToDriftDetectionMapOutputWithContext(ctx context.Context) DriftDetectionMapOutput {
	return o
}

func (o DriftDetectionMapOutput) MapIndex(k pulumi.StringInput) DriftDetectionOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *DriftDetection {
		return vs[0].(map[string]*DriftDetection)[vs[1].(string)]
	}).(DriftDetectionOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*DriftDetectionInput)(nil)).Elem(), &DriftDetection{})
	pulumi.RegisterInputType(reflect.TypeOf((*DriftDetectionArrayInput)(nil)).Elem(), DriftDetectionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DriftDetectionMapInput)(nil)).Elem(), DriftDetectionMap{})
	pulumi.RegisterOutputType(DriftDetectionOutput{})
	pulumi.RegisterOutputType(DriftDetectionArrayOutput{})
	pulumi.RegisterOutputType(DriftDetectionMapOutput{})
}
