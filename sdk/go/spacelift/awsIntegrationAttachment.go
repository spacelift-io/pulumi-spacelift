// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package spacelift

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/spacelift-io/pulumi-spacelift/sdk/v2/go/spacelift/internal"
)

// `AwsIntegrationAttachment` represents the attachment between a reusable AWS integration and a single stack or module.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/spacelift-io/pulumi-spacelift/sdk/v2/go/spacelift"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			// For a stack
//			_, err := spacelift.NewAwsIntegrationAttachment(ctx, "thisAwsIntegrationAttachment", &spacelift.AwsIntegrationAttachmentArgs{
//				IntegrationId: pulumi.Any(spacelift_aws_integration.This.Id),
//				StackId:       pulumi.String("my-stack-id"),
//				Read:          pulumi.Bool(true),
//				Write:         pulumi.Bool(true),
//			}, pulumi.DependsOn([]pulumi.Resource{
//				aws_iam_role.This,
//			}))
//			if err != nil {
//				return err
//			}
//			// For a module
//			_, err = spacelift.NewAwsIntegrationAttachment(ctx, "thisIndex/awsIntegrationAttachmentAwsIntegrationAttachment", &spacelift.AwsIntegrationAttachmentArgs{
//				IntegrationId: pulumi.Any(spacelift_aws_integration.This.Id),
//				ModuleId:      pulumi.String("my-module-id"),
//				Read:          pulumi.Bool(true),
//				Write:         pulumi.Bool(true),
//			}, pulumi.DependsOn([]pulumi.Resource{
//				aws_iam_role.This,
//			}))
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// ```sh
//
//	$ pulumi import spacelift:index/awsIntegrationAttachment:AwsIntegrationAttachment read_write_my_stack $INTEGRATION_ID/$PROJECT_ID
//
// ```
type AwsIntegrationAttachment struct {
	pulumi.CustomResourceState

	// Internal ID of the attachment entity
	AttachmentId pulumi.StringOutput `pulumi:"attachmentId"`
	// ID of the integration to attach
	IntegrationId pulumi.StringOutput `pulumi:"integrationId"`
	// ID of the module to attach the integration to
	ModuleId pulumi.StringPtrOutput `pulumi:"moduleId"`
	// Indicates whether this attachment is used for read operations. Defaults to `true`.
	Read pulumi.BoolPtrOutput `pulumi:"read"`
	// ID of the stack to attach the integration to
	StackId pulumi.StringPtrOutput `pulumi:"stackId"`
	// Indicates whether this attachment is used for write operations. Defaults to `true`.
	Write pulumi.BoolPtrOutput `pulumi:"write"`
}

// NewAwsIntegrationAttachment registers a new resource with the given unique name, arguments, and options.
func NewAwsIntegrationAttachment(ctx *pulumi.Context,
	name string, args *AwsIntegrationAttachmentArgs, opts ...pulumi.ResourceOption) (*AwsIntegrationAttachment, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.IntegrationId == nil {
		return nil, errors.New("invalid value for required argument 'IntegrationId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource AwsIntegrationAttachment
	err := ctx.RegisterResource("spacelift:index/awsIntegrationAttachment:AwsIntegrationAttachment", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetAwsIntegrationAttachment gets an existing AwsIntegrationAttachment resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetAwsIntegrationAttachment(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *AwsIntegrationAttachmentState, opts ...pulumi.ResourceOption) (*AwsIntegrationAttachment, error) {
	var resource AwsIntegrationAttachment
	err := ctx.ReadResource("spacelift:index/awsIntegrationAttachment:AwsIntegrationAttachment", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering AwsIntegrationAttachment resources.
type awsIntegrationAttachmentState struct {
	// Internal ID of the attachment entity
	AttachmentId *string `pulumi:"attachmentId"`
	// ID of the integration to attach
	IntegrationId *string `pulumi:"integrationId"`
	// ID of the module to attach the integration to
	ModuleId *string `pulumi:"moduleId"`
	// Indicates whether this attachment is used for read operations. Defaults to `true`.
	Read *bool `pulumi:"read"`
	// ID of the stack to attach the integration to
	StackId *string `pulumi:"stackId"`
	// Indicates whether this attachment is used for write operations. Defaults to `true`.
	Write *bool `pulumi:"write"`
}

type AwsIntegrationAttachmentState struct {
	// Internal ID of the attachment entity
	AttachmentId pulumi.StringPtrInput
	// ID of the integration to attach
	IntegrationId pulumi.StringPtrInput
	// ID of the module to attach the integration to
	ModuleId pulumi.StringPtrInput
	// Indicates whether this attachment is used for read operations. Defaults to `true`.
	Read pulumi.BoolPtrInput
	// ID of the stack to attach the integration to
	StackId pulumi.StringPtrInput
	// Indicates whether this attachment is used for write operations. Defaults to `true`.
	Write pulumi.BoolPtrInput
}

func (AwsIntegrationAttachmentState) ElementType() reflect.Type {
	return reflect.TypeOf((*awsIntegrationAttachmentState)(nil)).Elem()
}

type awsIntegrationAttachmentArgs struct {
	// ID of the integration to attach
	IntegrationId string `pulumi:"integrationId"`
	// ID of the module to attach the integration to
	ModuleId *string `pulumi:"moduleId"`
	// Indicates whether this attachment is used for read operations. Defaults to `true`.
	Read *bool `pulumi:"read"`
	// ID of the stack to attach the integration to
	StackId *string `pulumi:"stackId"`
	// Indicates whether this attachment is used for write operations. Defaults to `true`.
	Write *bool `pulumi:"write"`
}

// The set of arguments for constructing a AwsIntegrationAttachment resource.
type AwsIntegrationAttachmentArgs struct {
	// ID of the integration to attach
	IntegrationId pulumi.StringInput
	// ID of the module to attach the integration to
	ModuleId pulumi.StringPtrInput
	// Indicates whether this attachment is used for read operations. Defaults to `true`.
	Read pulumi.BoolPtrInput
	// ID of the stack to attach the integration to
	StackId pulumi.StringPtrInput
	// Indicates whether this attachment is used for write operations. Defaults to `true`.
	Write pulumi.BoolPtrInput
}

func (AwsIntegrationAttachmentArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*awsIntegrationAttachmentArgs)(nil)).Elem()
}

type AwsIntegrationAttachmentInput interface {
	pulumi.Input

	ToAwsIntegrationAttachmentOutput() AwsIntegrationAttachmentOutput
	ToAwsIntegrationAttachmentOutputWithContext(ctx context.Context) AwsIntegrationAttachmentOutput
}

func (*AwsIntegrationAttachment) ElementType() reflect.Type {
	return reflect.TypeOf((**AwsIntegrationAttachment)(nil)).Elem()
}

func (i *AwsIntegrationAttachment) ToAwsIntegrationAttachmentOutput() AwsIntegrationAttachmentOutput {
	return i.ToAwsIntegrationAttachmentOutputWithContext(context.Background())
}

func (i *AwsIntegrationAttachment) ToAwsIntegrationAttachmentOutputWithContext(ctx context.Context) AwsIntegrationAttachmentOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AwsIntegrationAttachmentOutput)
}

// AwsIntegrationAttachmentArrayInput is an input type that accepts AwsIntegrationAttachmentArray and AwsIntegrationAttachmentArrayOutput values.
// You can construct a concrete instance of `AwsIntegrationAttachmentArrayInput` via:
//
//	AwsIntegrationAttachmentArray{ AwsIntegrationAttachmentArgs{...} }
type AwsIntegrationAttachmentArrayInput interface {
	pulumi.Input

	ToAwsIntegrationAttachmentArrayOutput() AwsIntegrationAttachmentArrayOutput
	ToAwsIntegrationAttachmentArrayOutputWithContext(context.Context) AwsIntegrationAttachmentArrayOutput
}

type AwsIntegrationAttachmentArray []AwsIntegrationAttachmentInput

func (AwsIntegrationAttachmentArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AwsIntegrationAttachment)(nil)).Elem()
}

func (i AwsIntegrationAttachmentArray) ToAwsIntegrationAttachmentArrayOutput() AwsIntegrationAttachmentArrayOutput {
	return i.ToAwsIntegrationAttachmentArrayOutputWithContext(context.Background())
}

func (i AwsIntegrationAttachmentArray) ToAwsIntegrationAttachmentArrayOutputWithContext(ctx context.Context) AwsIntegrationAttachmentArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AwsIntegrationAttachmentArrayOutput)
}

// AwsIntegrationAttachmentMapInput is an input type that accepts AwsIntegrationAttachmentMap and AwsIntegrationAttachmentMapOutput values.
// You can construct a concrete instance of `AwsIntegrationAttachmentMapInput` via:
//
//	AwsIntegrationAttachmentMap{ "key": AwsIntegrationAttachmentArgs{...} }
type AwsIntegrationAttachmentMapInput interface {
	pulumi.Input

	ToAwsIntegrationAttachmentMapOutput() AwsIntegrationAttachmentMapOutput
	ToAwsIntegrationAttachmentMapOutputWithContext(context.Context) AwsIntegrationAttachmentMapOutput
}

type AwsIntegrationAttachmentMap map[string]AwsIntegrationAttachmentInput

func (AwsIntegrationAttachmentMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AwsIntegrationAttachment)(nil)).Elem()
}

func (i AwsIntegrationAttachmentMap) ToAwsIntegrationAttachmentMapOutput() AwsIntegrationAttachmentMapOutput {
	return i.ToAwsIntegrationAttachmentMapOutputWithContext(context.Background())
}

func (i AwsIntegrationAttachmentMap) ToAwsIntegrationAttachmentMapOutputWithContext(ctx context.Context) AwsIntegrationAttachmentMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AwsIntegrationAttachmentMapOutput)
}

type AwsIntegrationAttachmentOutput struct{ *pulumi.OutputState }

func (AwsIntegrationAttachmentOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AwsIntegrationAttachment)(nil)).Elem()
}

func (o AwsIntegrationAttachmentOutput) ToAwsIntegrationAttachmentOutput() AwsIntegrationAttachmentOutput {
	return o
}

func (o AwsIntegrationAttachmentOutput) ToAwsIntegrationAttachmentOutputWithContext(ctx context.Context) AwsIntegrationAttachmentOutput {
	return o
}

// Internal ID of the attachment entity
func (o AwsIntegrationAttachmentOutput) AttachmentId() pulumi.StringOutput {
	return o.ApplyT(func(v *AwsIntegrationAttachment) pulumi.StringOutput { return v.AttachmentId }).(pulumi.StringOutput)
}

// ID of the integration to attach
func (o AwsIntegrationAttachmentOutput) IntegrationId() pulumi.StringOutput {
	return o.ApplyT(func(v *AwsIntegrationAttachment) pulumi.StringOutput { return v.IntegrationId }).(pulumi.StringOutput)
}

// ID of the module to attach the integration to
func (o AwsIntegrationAttachmentOutput) ModuleId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AwsIntegrationAttachment) pulumi.StringPtrOutput { return v.ModuleId }).(pulumi.StringPtrOutput)
}

// Indicates whether this attachment is used for read operations. Defaults to `true`.
func (o AwsIntegrationAttachmentOutput) Read() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *AwsIntegrationAttachment) pulumi.BoolPtrOutput { return v.Read }).(pulumi.BoolPtrOutput)
}

// ID of the stack to attach the integration to
func (o AwsIntegrationAttachmentOutput) StackId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AwsIntegrationAttachment) pulumi.StringPtrOutput { return v.StackId }).(pulumi.StringPtrOutput)
}

// Indicates whether this attachment is used for write operations. Defaults to `true`.
func (o AwsIntegrationAttachmentOutput) Write() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *AwsIntegrationAttachment) pulumi.BoolPtrOutput { return v.Write }).(pulumi.BoolPtrOutput)
}

type AwsIntegrationAttachmentArrayOutput struct{ *pulumi.OutputState }

func (AwsIntegrationAttachmentArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AwsIntegrationAttachment)(nil)).Elem()
}

func (o AwsIntegrationAttachmentArrayOutput) ToAwsIntegrationAttachmentArrayOutput() AwsIntegrationAttachmentArrayOutput {
	return o
}

func (o AwsIntegrationAttachmentArrayOutput) ToAwsIntegrationAttachmentArrayOutputWithContext(ctx context.Context) AwsIntegrationAttachmentArrayOutput {
	return o
}

func (o AwsIntegrationAttachmentArrayOutput) Index(i pulumi.IntInput) AwsIntegrationAttachmentOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *AwsIntegrationAttachment {
		return vs[0].([]*AwsIntegrationAttachment)[vs[1].(int)]
	}).(AwsIntegrationAttachmentOutput)
}

type AwsIntegrationAttachmentMapOutput struct{ *pulumi.OutputState }

func (AwsIntegrationAttachmentMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AwsIntegrationAttachment)(nil)).Elem()
}

func (o AwsIntegrationAttachmentMapOutput) ToAwsIntegrationAttachmentMapOutput() AwsIntegrationAttachmentMapOutput {
	return o
}

func (o AwsIntegrationAttachmentMapOutput) ToAwsIntegrationAttachmentMapOutputWithContext(ctx context.Context) AwsIntegrationAttachmentMapOutput {
	return o
}

func (o AwsIntegrationAttachmentMapOutput) MapIndex(k pulumi.StringInput) AwsIntegrationAttachmentOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *AwsIntegrationAttachment {
		return vs[0].(map[string]*AwsIntegrationAttachment)[vs[1].(string)]
	}).(AwsIntegrationAttachmentOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AwsIntegrationAttachmentInput)(nil)).Elem(), &AwsIntegrationAttachment{})
	pulumi.RegisterInputType(reflect.TypeOf((*AwsIntegrationAttachmentArrayInput)(nil)).Elem(), AwsIntegrationAttachmentArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AwsIntegrationAttachmentMapInput)(nil)).Elem(), AwsIntegrationAttachmentMap{})
	pulumi.RegisterOutputType(AwsIntegrationAttachmentOutput{})
	pulumi.RegisterOutputType(AwsIntegrationAttachmentArrayOutput{})
	pulumi.RegisterOutputType(AwsIntegrationAttachmentMapOutput{})
}
